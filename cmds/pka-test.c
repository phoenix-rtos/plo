/*
 * Phoenix-RTOS
 *
 * Operating system loader
 *
 * encrypt external memory on STM32N6
 *
 * Copyright 2025 Phoenix Systems
 * Author: Krzysztof Radzewicz
 *
 * This file is part of Phoenix-RTOS.
 *
 * %LICENSE%
 */

#include "cmd.h"

#include <devices/devs.h>
#include <hal/hal.h>
#include <lib/lib.h>

#include <hal/armv8m/stm32/n6/pka.h>
#include <hal/armv8m/stm32/n6/hash.h>

#define KEYLEN PKA_ECC256_BYTES

static void cmd_pkaInfo(void)
{
	lib_printf("tmp");
}


static __attribute__((unused)) void print_buf(const u8 *buf, size_t size)
{
	for (size_t i = 0; i < size; i++) {
		lib_printf("%02x ", buf[i]);
		if (i % 16 == 15) {
			lib_printf("\n");
		}
	}
}


static __attribute__((unused)) int cmd_addtest(int argc, char *argv[])
{
	// u64 n = 200;
	// u64 a = 123;
	// u64 b = 143;
	// u64 out = 0;

	// pka_modAdd(&a, &b, &n, 8, &out);

	// lib_printf("\n");
	// lib_printf("arithmetic: a + b mod n =%lld\n", (a + b) % n);
	// lib_printf("pka: a + b mod n =%lld\n", out);

	return CMD_EXIT_SUCCESS;
}

__attribute__((unused)) int cmd_modexptest(int argc, char *argv[])
{
	// int ret;
	// u8 e = argv[1][0] - '0';
	// static u8 base[8] = {0x3};
	// static u8 exp[8] = {};
	// exp[0] = e;
	// static u8 n[8] = {0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1};
	// static u8 out[8] = {};
	// lib_printf("\n");

	// ret = pka_modExpFast(base, exp, n, 8, out);
	// if (ret == 0) {
	// 	lib_printf("Success\n");
	// 	print_buf(out, 8);
	// }
	// else {
	// 	lib_printf("returned: %d\n", ret);
	// }

	return CMD_EXIT_SUCCESS;
}

__attribute__((unused)) static int cmd_pkatest(int argc, char *argv[])
{
	int ret;
	// static u8 private[KEYLEN] = {
	// 	0xe8, 0x0a, 0xbf, 0xd2, 0xde, 0x07, 0x99, 0x40,
	// 	0x81, 0xcf, 0xff, 0x0e, 0xac, 0x63, 0xca, 0x28,
	// 	0x3a, 0xae, 0x57, 0x74, 0x17, 0x64, 0x9d, 0x29,
	// 	0x78, 0x98, 0xd2, 0xfe, 0xd6, 0xef, 0xd6, 0x47
	// };
	static u8 public[2 * KEYLEN] = {
		0xa1, 0x17, 0x15, 0x84, 0x42, 0xbb, 0x11, 0xa2,
		0x8d, 0x1b, 0x73, 0x20, 0x36, 0x84, 0x35, 0xd4,
		0x4b, 0xea, 0x37, 0xb8, 0x5d, 0xf9, 0x02, 0xba,
		0xd2, 0x1c, 0xf0, 0x9c, 0xa7, 0xb0, 0xb1, 0x7a,

		0xb2, 0xe5, 0x70, 0xc6, 0xe1, 0xf0, 0x78, 0xdc,
		0xa4, 0x56, 0x20, 0xbf, 0x66, 0x38, 0xa9, 0x1d,
		0x4b, 0x2c, 0xb2, 0x54, 0xa8, 0x96, 0x8f, 0x02,
		0x25, 0x23, 0x8c, 0xda, 0xa3, 0xd8, 0x0f, 0x0c
	};
	u8 *Qx = public;
	u8 *Qy = public + KEYLEN;
	static u8 sig[2 * KEYLEN] = { // calculated in python
		0x45, 0x43, 0x79, 0xcc, 0x31, 0x3b, 0x8d, 0x05,
		0xbe, 0x89, 0x8e, 0x9c, 0x34, 0xd3, 0x03, 0x6f,
		0x91, 0x81, 0xe5, 0xe7, 0x11, 0x8e, 0x50, 0xb3,
		0x70, 0x13, 0xe6, 0x99, 0x45, 0x42, 0x89, 0x5d,

		0x9c, 0x8d, 0x12, 0xd9, 0xb7, 0x07, 0xcd, 0x8c,
		0x59, 0x1f, 0x21, 0x18, 0x3e, 0x12, 0x59, 0xe0,
		0xf4, 0xa3, 0x56, 0xe0, 0x4b, 0xc2, 0x93, 0x3d,
		0x31, 0x23, 0xcf, 0xb1, 0x3f, 0xa8, 0x34, 0x13
	};
	u8 *r = sig;
	u8 *s = sig + KEYLEN;
	static u8 hash[KEYLEN] = {
		// 0x25, 0x68, 0x89, 0xbd, 0x1f, 0xd8, 0x44, 0xb3,
		// 0xf2, 0x0b, 0xed, 0xf0, 0x38, 0x1a, 0xcc, 0xeb,
		// 0x7e, 0xf1, 0x85, 0x10, 0x0e, 0x02, 0x8e, 0xd5,
		// 0xc7, 0x4b, 0x9d, 0xce, 0x29, 0x5c, 0x70, 0xae,
		// 0x1e, 0x23, 0x80, 0x82, 0x87, 0x4c, 0x72, 0xb5,
		// 0x4b, 0x90, 0x4d, 0x16, 0xd6, 0x52, 0xa4, 0x31
	};

#define MESS_LEN 12
	/* Message bytes need to be in regular order */
	static u8 mess[MESS_LEN] = {
		0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f,
		0x72, 0x6c, 0x64, 0x21
	};

	lib_printf("\n");

	ret = hash_digest(HASH_ALGO_SHA2_256, mess, MESS_LEN, hash, KEYLEN);
	if (ret < 0) {
		lib_printf("hash_digest: %d\n", ret);
		return CMD_EXIT_FAILURE;
	}
	lib_printf("Produced hash:\n");
	print_buf(hash, KEYLEN);

	// ret = pka_ecdsaSign(hash, private, KEYLEN * 8, r, s);
	// if (ret == 0) {
	// 	lib_printf("Sign success\n");
	// }
	// else {
	// 	lib_printf("pka_ecdsaSign: %d\n", ret);
	// 	return CMD_EXIT_FAILURE;
	// }

	// ret = pka_eccPubKey(private, KEYLEN * 8, Qx, Qy);
	// if (ret == 0) {
	// 	lib_printf("Success\n");
	// }
	// else {
	// 	lib_printf("pka_eccPubKey: %d\n", ret);
	// 	return CMD_EXIT_FAILURE;
	// }

	lib_printf("Qx:\n");
	print_buf(Qx, KEYLEN);
	lib_printf("Qy:\n");
	print_buf(Qy, KEYLEN);

	lib_printf("r:\n");
	print_buf(r, KEYLEN);
	lib_printf("s:\n");
	print_buf(s, KEYLEN);

	ret = pka_ecdsaVerify(r, s, hash, Qx, Qy, KEYLEN * 8);
	if (ret == 0) {
		lib_printf("Success\n");
	}
	else {
		lib_printf("pka_ecdsaVerify: %d\n", ret);
		return CMD_EXIT_FAILURE;
	}

	return CMD_EXIT_SUCCESS;
}


#define MESS_SZ 100
#define HASH_SZ (256 / 8)

__attribute__((unused)) static int cmd_hashtest(int argc, char *argv[])
{
	static u8 mess[MESS_SZ] = {
 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 
 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 
 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 
 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 
 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 
 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 
 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 
 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 
 0x60, 0x61, 0x62, 0x63 
};

	static u8 hash[HASH_SZ] = {
	
	};

	hash_initDigest(HASH_ALGO_SHA2_256);
	for (int i = 0; i < 99; i += 3) {
		lib_printf("%d-%d\n", i, i + 2);
		hash_feedMessage(mess + i, 3);
	}
	hash_feedMessage(mess + 99, 1);
	hash_getDigest(hash, HASH_SZ);
	/* WHAT I FOUND: partial feed breaks when data length is not divisible by 4*/
	// hash_digest(HASH_ALGO_SHA2_256, mess, MESS_SZ, hash, HASH_SZ);

	lib_printf("\nSHA2-256:\n");
	lib_printf("Message:\n");
	print_buf(mess, MESS_SZ);
	lib_printf("\nDigest:\n");
	print_buf(hash, HASH_SZ);

	return CMD_EXIT_SUCCESS;
}

__attribute__((unused)) static int cmd_htest(int argc, char *argv[])
{
	u8 buf[32] = { 59 };
	hash_initDigest(HASH_ALGO_SHA2_256);
	hash_feedMessage(buf, 1);
	hash_getDigest(buf, 32);

	lib_printf("\n");
	print_buf(buf, 32);

	return CMD_EXIT_SUCCESS;
}


static const cmd_t pkatest_cmd __attribute__((section("commands"), used)) = {
	.name = "pka-test", .run = cmd_htest, .info = cmd_pkaInfo
};
